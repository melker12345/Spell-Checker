(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.nspell = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

var push = require('./util/add.js')

module.exports = add

var NO_CODES = []

// Add `value` to the checker.
function add(value, model) {
  var self = this

  push(self.data, value, self.data[model] || NO_CODES, self)

  return self
}

},{"./util/add.js":9}],2:[function(require,module,exports){
'use strict'

var form = require('./util/form.js')

module.exports = correct

// Check spelling of `value`.
function correct(value) {
  return Boolean(form(this, value))
}

},{"./util/form.js":16}],3:[function(require,module,exports){
'use strict'

var parse = require('./util/dictionary.js')

module.exports = add

// Add a dictionary file.
function add(buf) {
  var self = this
  var index = -1
  var rule
  var source
  var character
  var offset

  parse(buf, self, self.data)

  // Regenerate compound expressions.
  while (++index < self.compoundRules.length) {
    rule = self.compoundRules[index]
    source = ''
    offset = -1

    while (++offset < rule.length) {
      character = rule.charAt(offset)
      source += self.compoundRuleCodes[character].length
        ? '(?:' + self.compoundRuleCodes[character].join('|') + ')'
        : character
    }

    self.compoundRules[index] = new RegExp(source, 'i')
  }

  return self
}

},{"./util/dictionary.js":13}],4:[function(require,module,exports){
'use strict'

var buffer = require('is-buffer')
var affix = require('./util/affix.js')

module.exports = NSpell

var proto = NSpell.prototype

proto.correct = require('./correct.js')
proto.suggest = require('./suggest.js')
proto.spell = require('./spell.js')
proto.add = require('./add.js')
proto.remove = require('./remove.js')
proto.wordCharacters = require('./word-characters.js')
proto.dictionary = require('./dictionary.js')
proto.personal = require('./personal.js')

// Construct a new spelling context.
function NSpell(aff, dic) {
  var index = -1
  var dictionaries

  if (!(this instanceof NSpell)) {
    return new NSpell(aff, dic)
  }

  if (typeof aff === 'string' || buffer(aff)) {
    if (typeof dic === 'string' || buffer(dic)) {
      dictionaries = [{dic: dic}]
    }
  } else if (aff) {
    if ('length' in aff) {
      dictionaries = aff
      aff = aff[0] && aff[0].aff
    } else {
      if (aff.dic) {
        dictionaries = [aff]
      }

      aff = aff.aff
    }
  }

  if (!aff) {
    throw new Error('Missing `aff` in dictionary')
  }

  aff = affix(aff)

  this.data = Object.create(null)
  this.compoundRuleCodes = aff.compoundRuleCodes
  this.replacementTable = aff.replacementTable
  this.conversion = aff.conversion
  this.compoundRules = aff.compoundRules
  this.rules = aff.rules
  this.flags = aff.flags

  if (dictionaries) {
    while (++index < dictionaries.length) {
      if (dictionaries[index].dic) {
        this.dictionary(dictionaries[index].dic)
      }
    }
  }
}

},{"./add.js":1,"./correct.js":2,"./dictionary.js":3,"./personal.js":5,"./remove.js":6,"./spell.js":7,"./suggest.js":8,"./util/affix.js":10,"./word-characters.js":19,"is-buffer":20}],5:[function(require,module,exports){
'use strict'

module.exports = add

// Add a dictionary.
function add(buf) {
  var self = this
  var lines = buf.toString('utf8').split('\n')
  var index = -1
  var line
  var forbidden
  var word
  var flag

  // Ensure there’s a key for `FORBIDDENWORD`: `false` cannot be set through an
  // affix file so its safe to use as a magic constant.
  if (self.flags.FORBIDDENWORD === undefined) self.flags.FORBIDDENWORD = false
  flag = self.flags.FORBIDDENWORD

  while (++index < lines.length) {
    line = lines[index].trim()

    if (!line) {
      continue
    }

    line = line.split('/')
    word = line[0]
    forbidden = word.charAt(0) === '*'

    if (forbidden) {
      word = word.slice(1)
    }

    self.add(word, line[1])

    if (forbidden) {
      self.data[word].push(flag)
    }
  }

  return self
}

},{}],6:[function(require,module,exports){
'use strict'

module.exports = remove

// Remove `value` from the checker.
function remove(value) {
  var self = this

  delete self.data[value]

  return self
}

},{}],7:[function(require,module,exports){
'use strict'

var form = require('./util/form.js')
var flag = require('./util/flag.js')

module.exports = spell

// Check spelling of `word`.
function spell(word) {
  var self = this
  var value = form(self, word, true)

  // Hunspell also provides `root` (root word of the input word), and `compound`
  // (whether `word` was compound).
  return {
    correct: self.correct(word),
    forbidden: Boolean(
      value && flag(self.flags, 'FORBIDDENWORD', self.data[value])
    ),
    warn: Boolean(value && flag(self.flags, 'WARN', self.data[value]))
  }
}

},{"./util/flag.js":15,"./util/form.js":16}],8:[function(require,module,exports){
'use strict'

var casing = require('./util/casing.js')
var normalize = require('./util/normalize.js')
var flag = require('./util/flag.js')
var form = require('./util/form.js')

module.exports = suggest

var push = [].push

// Suggest spelling for `value`.
// eslint-disable-next-line complexity
function suggest(value) {
  var self = this
  var charAdded = {}
  var suggestions = []
  var weighted = {}
  var memory
  var replacement
  var edits = []
  var values
  var index
  var offset
  var position
  var count
  var otherOffset
  var otherCharacter
  var character
  var group
  var before
  var after
  var upper
  var insensitive
  var firstLevel
  var previous
  var next
  var nextCharacter
  var max
  var distance
  var size
  var normalized
  var suggestion
  var currentCase

  value = normalize(value.trim(), self.conversion.in)

  if (!value || self.correct(value)) {
    return []
  }

  currentCase = casing(value)

  // Check the replacement table.
  index = -1

  while (++index < self.replacementTable.length) {
    replacement = self.replacementTable[index]
    offset = value.indexOf(replacement[0])

    while (offset > -1) {
      edits.push(value.replace(replacement[0], replacement[1]))
      offset = value.indexOf(replacement[0], offset + 1)
    }
  }

  // Check the keyboard.
  index = -1

  while (++index < value.length) {
    character = value.charAt(index)
    before = value.slice(0, index)
    after = value.slice(index + 1)
    insensitive = character.toLowerCase()
    upper = insensitive !== character
    charAdded = {}

    offset = -1

    while (++offset < self.flags.KEY.length) {
      group = self.flags.KEY[offset]
      position = group.indexOf(insensitive)

      if (position < 0) {
        continue
      }

      otherOffset = -1

      while (++otherOffset < group.length) {
        if (otherOffset !== position) {
          otherCharacter = group.charAt(otherOffset)

          if (charAdded[otherCharacter]) {
            continue
          }

          charAdded[otherCharacter] = true

          if (upper) {
            otherCharacter = otherCharacter.toUpperCase()
          }

          edits.push(before + otherCharacter + after)
        }
      }
    }
  }

  // Check cases where one of a double character was forgotten, or one too many
  // were added, up to three “distances”.  This increases the success-rate by 2%
  // and speeds the process up by 13%.
  index = -1
  nextCharacter = value.charAt(0)
  values = ['']
  max = 1
  distance = 0

  while (++index < value.length) {
    character = nextCharacter
    nextCharacter = value.charAt(index + 1)
    before = value.slice(0, index)

    replacement = character === nextCharacter ? '' : character + character
    offset = -1
    count = values.length

    while (++offset < count) {
      if (offset <= max) {
        values.push(values[offset] + replacement)
      }

      values[offset] += character
    }

    if (++distance < 3) {
      max = values.length
    }
  }

  push.apply(edits, values)

  // Ensure the capitalised and uppercase values are included.
  values = [value]
  replacement = value.toLowerCase()

  if (value === replacement || currentCase === null) {
    values.push(value.charAt(0).toUpperCase() + replacement.slice(1))
  }

  replacement = value.toUpperCase()

  if (value !== replacement) {
    values.push(replacement)
  }

  // Construct a memory object for `generate`.
  memory = {
    state: {},
    weighted: weighted,
    suggestions: suggestions
  }

  firstLevel = generate(self, memory, values, edits)

  // While there are no suggestions based on generated values with an
  // edit-distance of `1`, check the generated values, `SIZE` at a time.
  // Basically, we’re generating values with an edit-distance of `2`, but were
  // doing it in small batches because it’s such an expensive operation.
  previous = 0
  max = Math.min(firstLevel.length, Math.pow(Math.max(15 - value.length, 3), 3))
  size = Math.max(Math.pow(10 - value.length, 3), 1)

  while (!suggestions.length && previous < max) {
    next = previous + size
    generate(self, memory, firstLevel.slice(previous, next))
    previous = next
  }

  // Sort the suggestions based on their weight.
  suggestions.sort(sort)

  // Normalize the output.
  values = []
  normalized = []
  index = -1

  while (++index < suggestions.length) {
    suggestion = normalize(suggestions[index], self.conversion.out)
    replacement = suggestion.toLowerCase()

    if (normalized.indexOf(replacement) < 0) {
      values.push(suggestion)
      normalized.push(replacement)
    }
  }

  // BOOM! All done!
  return values

  function sort(a, b) {
    return sortWeight(a, b) || sortCasing(a, b) || sortAlpha(a, b)
  }

  function sortWeight(a, b) {
    return weighted[a] === weighted[b] ? 0 : weighted[a] > weighted[b] ? -1 : 1
  }

  function sortCasing(a, b) {
    var leftCasing = casing(a)
    var rightCasing = casing(b)

    return leftCasing === rightCasing
      ? 0
      : leftCasing === currentCase
      ? -1
      : rightCasing === currentCase
      ? 1
      : undefined
  }

  function sortAlpha(a, b) {
    return a.localeCompare(b)
  }
}

// Get a list of values close in edit distance to `words`.
function generate(context, memory, words, edits) {
  var characters = context.flags.TRY
  var data = context.data
  var flags = context.flags
  var result = []
  var index = -1
  var word
  var before
  var character
  var nextCharacter
  var nextAfter
  var nextNextAfter
  var nextUpper
  var currentCase
  var position
  var after
  var upper
  var inject
  var offset

  // Check the pre-generated edits.
  if (edits) {
    while (++index < edits.length) {
      check(edits[index], true)
    }
  }

  // Iterate over given word.
  index = -1

  while (++index < words.length) {
    word = words[index]
    before = ''
    character = ''
    nextCharacter = word.charAt(0)
    nextAfter = word
    nextNextAfter = word.slice(1)
    nextUpper = nextCharacter.toLowerCase() !== nextCharacter
    currentCase = casing(word)
    position = -1

    // Iterate over every character (including the end).
    while (++position <= word.length) {
      before += character
      after = nextAfter
      nextAfter = nextNextAfter
      nextNextAfter = nextAfter.slice(1)
      character = nextCharacter
      nextCharacter = word.charAt(position + 1)
      upper = nextUpper

      if (nextCharacter) {
        nextUpper = nextCharacter.toLowerCase() !== nextCharacter
      }

      if (nextAfter && upper !== nextUpper) {
        // Remove.
        check(before + switchCase(nextAfter))

        // Switch.
        check(
          before +
            switchCase(nextCharacter) +
            switchCase(character) +
            nextNextAfter
        )
      }

      // Remove.
      check(before + nextAfter)

      // Switch.
      if (nextAfter) {
        check(before + nextCharacter + character + nextNextAfter)
      }

      // Iterate over all possible letters.
      offset = -1

      while (++offset < characters.length) {
        inject = characters[offset]

        // Try uppercase if the original character was uppercased.
        if (upper && inject !== inject.toUpperCase()) {
          if (currentCase !== 's') {
            check(before + inject + after)
            check(before + inject + nextAfter)
          }

          inject = inject.toUpperCase()

          check(before + inject + after)
          check(before + inject + nextAfter)
        } else {
          // Add and replace.
          check(before + inject + after)
          check(before + inject + nextAfter)
        }
      }
    }
  }

  // Return the list of generated words.
  return result

  // Check and handle a generated value.
  function check(value, double) {
    var state = memory.state[value]
    var corrected

    if (state !== Boolean(state)) {
      result.push(value)

      corrected = form(context, value)
      state = corrected && !flag(flags, 'NOSUGGEST', data[corrected])

      memory.state[value] = state

      if (state) {
        memory.weighted[value] = double ? 10 : 0
        memory.suggestions.push(value)
      }
    }

    if (state) {
      memory.weighted[value]++
    }
  }

  function switchCase(fragment) {
    var first = fragment.charAt(0)

    return (
      (first.toLowerCase() === first
        ? first.toUpperCase()
        : first.toLowerCase()) + fragment.slice(1)
    )
  }
}

},{"./util/casing.js":12,"./util/flag.js":15,"./util/form.js":16,"./util/normalize.js":17}],9:[function(require,module,exports){
'use strict'

var apply = require('./apply.js')

module.exports = add

var push = [].push

var NO_RULES = []

// Add `rules` for `word` to the table.
function addRules(dict, word, rules) {
  var curr = dict[word]

  // Some dictionaries will list the same word multiple times with different
  // rule sets.
  if (word in dict) {
    if (curr === NO_RULES) {
      dict[word] = rules.concat()
    } else {
      push.apply(curr, rules)
    }
  } else {
    dict[word] = rules.concat()
  }
}

function add(dict, word, codes, options) {
  var position = -1
  var rule
  var offset
  var subposition
  var suboffset
  var combined
  var newWords
  var otherNewWords

  // Compound words.
  if (
    !('NEEDAFFIX' in options.flags) ||
    codes.indexOf(options.flags.NEEDAFFIX) < 0
  ) {
    addRules(dict, word, codes)
  }

  while (++position < codes.length) {
    rule = options.rules[codes[position]]

    if (codes[position] in options.compoundRuleCodes) {
      options.compoundRuleCodes[codes[position]].push(word)
    }

    if (rule) {
      newWords = apply(word, rule, options.rules, [])
      offset = -1

      while (++offset < newWords.length) {
        if (!(newWords[offset] in dict)) {
          dict[newWords[offset]] = NO_RULES
        }

        if (rule.combineable) {
          subposition = position

          while (++subposition < codes.length) {
            combined = options.rules[codes[subposition]]

            if (
              combined &&
              combined.combineable &&
              rule.type !== combined.type
            ) {
              otherNewWords = apply(
                newWords[offset],
                combined,
                options.rules,
                []
              )
              suboffset = -1

              while (++suboffset < otherNewWords.length) {
                if (!(otherNewWords[suboffset] in dict)) {
                  dict[otherNewWords[suboffset]] = NO_RULES
                }
              }
            }
          }
        }
      }
    }
  }
}

},{"./apply.js":11}],10:[function(require,module,exports){
'use strict'

var parse = require('./rule-codes.js')

module.exports = affix

var push = [].push

// Relative frequencies of letters in the English language.
var alphabet = 'etaoinshrdlcumwfgypbvkjxqz'.split('')

// Expressions.
var whiteSpaceExpression = /\s+/

// Defaults.
var defaultKeyboardLayout = [
  'qwertzuop',
  'yxcvbnm',
  'qaw',
  'say',
  'wse',
  'dsx',
  'sy',
  'edr',
  'fdc',
  'dx',
  'rft',
  'gfv',
  'fc',
  'tgz',
  'hgb',
  'gv',
  'zhu',
  'jhn',
  'hb',
  'uji',
  'kjm',
  'jn',
  'iko',
  'lkm'
]

// Parse an affix file.
// eslint-disable-next-line complexity
function affix(doc) {
  var rules = Object.create(null)
  var compoundRuleCodes = Object.create(null)
  var flags = Object.create(null)
  var replacementTable = []
  var conversion = {in: [], out: []}
  var compoundRules = []
  var aff = doc.toString('utf8')
  var lines = []
  var last = 0
  var index = aff.indexOf('\n')
  var parts
  var line
  var ruleType
  var count
  var remove
  var add
  var source
  var entry
  var position
  var rule
  var value
  var offset
  var character

  flags.KEY = []

  // Process the affix buffer into a list of applicable lines.
  while (index > -1) {
    pushLine(aff.slice(last, index))
    last = index + 1
    index = aff.indexOf('\n', last)
  }

  pushLine(aff.slice(last))

  // Process each line.
  index = -1

  while (++index < lines.length) {
    line = lines[index]
    parts = line.split(whiteSpaceExpression)
    ruleType = parts[0]

    if (ruleType === 'REP') {
      count = index + parseInt(parts[1], 10)

      while (++index <= count) {
        parts = lines[index].split(whiteSpaceExpression)
        replacementTable.push([parts[1], parts[2]])
      }

      index--
    } else if (ruleType === 'ICONV' || ruleType === 'OCONV') {
      count = index + parseInt(parts[1], 10)
      entry = conversion[ruleType === 'ICONV' ? 'in' : 'out']

      while (++index <= count) {
        parts = lines[index].split(whiteSpaceExpression)
        entry.push([new RegExp(parts[1], 'g'), parts[2]])
      }

      index--
    } else if (ruleType === 'COMPOUNDRULE') {
      count = index + parseInt(parts[1], 10)

      while (++index <= count) {
        rule = lines[index].split(whiteSpaceExpression)[1]
        position = -1

        compoundRules.push(rule)

        while (++position < rule.length) {
          compoundRuleCodes[rule.charAt(position)] = []
        }
      }

      index--
    } else if (ruleType === 'PFX' || ruleType === 'SFX') {
      count = index + parseInt(parts[3], 10)

      rule = {
        type: ruleType,
        combineable: parts[2] === 'Y',
        entries: []
      }

      rules[parts[1]] = rule

      while (++index <= count) {
        parts = lines[index].split(whiteSpaceExpression)
        remove = parts[2]
        add = parts[3].split('/')
        source = parts[4]

        entry = {
          add: '',
          remove: '',
          match: '',
          continuation: parse(flags, add[1])
        }

        if (add && add[0] !== '0') {
          entry.add = add[0]
        }

        try {
          if (remove !== '0') {
            entry.remove = ruleType === 'SFX' ? end(remove) : remove
          }

          if (source && source !== '.') {
            entry.match = ruleType === 'SFX' ? end(source) : start(source)
          }
        } catch (_) {
          // Ignore invalid regex patterns.
          entry = null
        }

        if (entry) {
          rule.entries.push(entry)
        }
      }

      index--
    } else if (ruleType === 'TRY') {
      source = parts[1]
      offset = -1
      value = []

      while (++offset < source.length) {
        character = source.charAt(offset)

        if (character.toLowerCase() === character) {
          value.push(character)
        }
      }

      // Some dictionaries may forget a character.
      // Notably `en` forgets `j`, `x`, and `y`.
      offset = -1

      while (++offset < alphabet.length) {
        if (source.indexOf(alphabet[offset]) < 0) {
          value.push(alphabet[offset])
        }
      }

      flags[ruleType] = value
    } else if (ruleType === 'KEY') {
      push.apply(flags[ruleType], parts[1].split('|'))
    } else if (ruleType === 'COMPOUNDMIN') {
      flags[ruleType] = Number(parts[1])
    } else if (ruleType === 'ONLYINCOMPOUND') {
      // If we add this ONLYINCOMPOUND flag to `compoundRuleCodes`, then
      // `parseDic` will do the work of saving the list of words that are
      // compound-only.
      flags[ruleType] = parts[1]
      compoundRuleCodes[parts[1]] = []
    } else if (
      ruleType === 'FLAG' ||
      ruleType === 'KEEPCASE' ||
      ruleType === 'NOSUGGEST' ||
      ruleType === 'WORDCHARS'
    ) {
      flags[ruleType] = parts[1]
    } else {
      // Default handling: set them for now.
      flags[ruleType] = parts[1]
    }
  }

  // Default for `COMPOUNDMIN` is `3`.
  // See `man 4 hunspell`.
  if (isNaN(flags.COMPOUNDMIN)) {
    flags.COMPOUNDMIN = 3
  }

  if (!flags.KEY.length) {
    flags.KEY = defaultKeyboardLayout
  }

  /* istanbul ignore if - Dictionaries seem to always have this. */
  if (!flags.TRY) {
    flags.TRY = alphabet.concat()
  }

  if (!flags.KEEPCASE) {
    flags.KEEPCASE = false
  }

  return {
    compoundRuleCodes: compoundRuleCodes,
    replacementTable: replacementTable,
    conversion: conversion,
    compoundRules: compoundRules,
    rules: rules,
    flags: flags
  }

  function pushLine(line) {
    line = line.trim()

    // Hash can be a valid flag, so we only discard line that starts with it.
    if (line && line.charCodeAt(0) !== 35 /* `#` */) {
      lines.push(line)
    }
  }
}

// Wrap the `source` of an expression-like string so that it matches only at
// the end of a value.
function end(source) {
  return new RegExp(source + '$')
}

// Wrap the `source` of an expression-like string so that it matches only at
// the start of a value.
function start(source) {
  return new RegExp('^' + source)
}

},{"./rule-codes.js":18}],11:[function(require,module,exports){
'use strict'

module.exports = apply

// Apply a rule.
function apply(value, rule, rules, words) {
  var index = -1
  var entry
  var next
  var continuationRule
  var continuation
  var position

  while (++index < rule.entries.length) {
    entry = rule.entries[index]
    continuation = entry.continuation
    position = -1

    if (!entry.match || entry.match.test(value)) {
      next = entry.remove ? value.replace(entry.remove, '') : value
      next = rule.type === 'SFX' ? next + entry.add : entry.add + next
      words.push(next)

      if (continuation && continuation.length) {
        while (++position < continuation.length) {
          continuationRule = rules[continuation[position]]

          if (continuationRule) {
            apply(next, continuationRule, rules, words)
          }
        }
      }
    }
  }

  return words
}

},{}],12:[function(require,module,exports){
'use strict'

module.exports = casing

// Get the casing of `value`.
function casing(value) {
  var head = exact(value.charAt(0))
  var rest = value.slice(1)

  if (!rest) {
    return head
  }

  rest = exact(rest)

  if (head === rest) {
    return head
  }

  if (head === 'u' && rest === 'l') {
    return 's'
  }

  return null
}

function exact(value) {
  return value === value.toLowerCase()
    ? 'l'
    : value === value.toUpperCase()
    ? 'u'
    : null
}

},{}],13:[function(require,module,exports){
'use strict'

var parseCodes = require('./rule-codes.js')
var add = require('./add.js')

module.exports = parse

// Expressions.
var whiteSpaceExpression = /\s/g

// Parse a dictionary.
function parse(buf, options, dict) {
  // Parse as lines (ignoring the first line).
  var value = buf.toString('utf8')
  var last = value.indexOf('\n') + 1
  var index = value.indexOf('\n', last)

  while (index > -1) {
    // Some dictionaries use tabs as comments.
    if (value.charCodeAt(last) !== 9 /* `\t` */) {
      parseLine(value.slice(last, index), options, dict)
    }

    last = index + 1
    index = value.indexOf('\n', last)
  }

  parseLine(value.slice(last), options, dict)
}

// Parse a line in dictionary.
function parseLine(line, options, dict) {
  var slashOffset = line.indexOf('/')
  var hashOffset = line.indexOf('#')
  var codes = ''
  var word
  var result

  // Find offsets.
  while (
    slashOffset > -1 &&
    line.charCodeAt(slashOffset - 1) === 92 /* `\` */
  ) {
    line = line.slice(0, slashOffset - 1) + line.slice(slashOffset)
    slashOffset = line.indexOf('/', slashOffset)
  }

  // Handle hash and slash offsets.
  // Note that hash can be a valid flag, so we should not just discard
  // everything after it.
  if (hashOffset > -1) {
    if (slashOffset > -1 && slashOffset < hashOffset) {
      word = line.slice(0, slashOffset)
      whiteSpaceExpression.lastIndex = slashOffset + 1
      result = whiteSpaceExpression.exec(line)
      codes = line.slice(slashOffset + 1, result ? result.index : undefined)
    } else {
      word = line.slice(0, hashOffset)
    }
  } else if (slashOffset > -1) {
    word = line.slice(0, slashOffset)
    codes = line.slice(slashOffset + 1)
  } else {
    word = line
  }

  word = word.trim()

  if (word) {
    add(dict, word, parseCodes(options.flags, codes.trim()), options)
  }
}

},{"./add.js":9,"./rule-codes.js":18}],14:[function(require,module,exports){
'use strict'

var flag = require('./flag.js')

module.exports = exact

// Check spelling of `value`, exactly.
function exact(context, value) {
  var index = -1

  if (context.data[value]) {
    return !flag(context.flags, 'ONLYINCOMPOUND', context.data[value])
  }

  // Check if this might be a compound word.
  if (value.length >= context.flags.COMPOUNDMIN) {
    while (++index < context.compoundRules.length) {
      if (context.compoundRules[index].test(value)) {
        return true
      }
    }
  }

  return false
}

},{"./flag.js":15}],15:[function(require,module,exports){
'use strict'

module.exports = flag

// Check whether a word has a flag.
function flag(values, value, flags) {
  return flags && value in values && flags.indexOf(values[value]) > -1
}

},{}],16:[function(require,module,exports){
'use strict'

var normalize = require('./normalize.js')
var exact = require('./exact.js')
var flag = require('./flag.js')

module.exports = form

// Find a known form of `value`.
function form(context, value, all) {
  var normal = value.trim()
  var alternative

  if (!normal) {
    return null
  }

  normal = normalize(normal, context.conversion.in)

  if (exact(context, normal)) {
    if (!all && flag(context.flags, 'FORBIDDENWORD', context.data[normal])) {
      return null
    }

    return normal
  }

  // Try sentence case if the value is uppercase.
  if (normal.toUpperCase() === normal) {
    alternative = normal.charAt(0) + normal.slice(1).toLowerCase()

    if (ignore(context.flags, context.data[alternative], all)) {
      return null
    }

    if (exact(context, alternative)) {
      return alternative
    }
  }

  // Try lowercase.
  alternative = normal.toLowerCase()

  if (alternative !== normal) {
    if (ignore(context.flags, context.data[alternative], all)) {
      return null
    }

    if (exact(context, alternative)) {
      return alternative
    }
  }

  return null
}

function ignore(flags, dict, all) {
  return (
    flag(flags, 'KEEPCASE', dict) || all || flag(flags, 'FORBIDDENWORD', dict)
  )
}

},{"./exact.js":14,"./flag.js":15,"./normalize.js":17}],17:[function(require,module,exports){
'use strict'

module.exports = normalize

// Normalize `value` with patterns.
function normalize(value, patterns) {
  var index = -1

  while (++index < patterns.length) {
    value = value.replace(patterns[index][0], patterns[index][1])
  }

  return value
}

},{}],18:[function(require,module,exports){
'use strict'

module.exports = ruleCodes

var NO_CODES = []

// Parse rule codes.
function ruleCodes(flags, value) {
  var index = 0
  var result

  if (!value) return NO_CODES

  if (flags.FLAG === 'long') {
    // Creating an array of the right length immediately
    // avoiding resizes and using memory more efficiently
    result = new Array(Math.ceil(value.length / 2))

    while (index < value.length) {
      result[index / 2] = value.slice(index, index + 2)
      index += 2
    }

    return result
  }

  return value.split(flags.FLAG === 'num' ? ',' : '')
}

},{}],19:[function(require,module,exports){
'use strict'

module.exports = wordCharacters

// Get the word characters defined in affix.
function wordCharacters() {
  return this.flags.WORDCHARS || null
}

},{}],20:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

},{}],21:[function(require,module,exports){
// Entry point for NSpell bundle
const nspell = require('nspell');

// Export the nspell factory function
module.exports = nspell;

},{"nspell":4}]},{},[21])(21)
});
